"""
Phase 7.D4: Otomatik Re-Training Sistemi
=========================================
Model performansƒ±nƒ± izler ve gerektiƒüinde otomatik re-training yapar.

√ñzellikler:
- Performans d√º≈ü√º≈ü√º algƒ±lama
- Otomatik veri g√ºncelleme
- Model re-training
- Versiyon y√∂netimi
- Backup/Rollback
- Email/webhook bildirimleri
- Scheduled execution (cron/task scheduler)

Kullanƒ±m:
    python auto_retrain.py
    
    # Performans kontrol√º
    python auto_retrain.py --check-only
    
    # Zorla re-training
    python auto_retrain.py --force
    
    # Belirli bir model
    python auto_retrain.py --model xgboost
    
    # Scheduled (her g√ºn 03:00)
    # Windows: Task Scheduler ile
    # Linux: crontab -e
    # 0 3 * * * /usr/bin/python3 /path/to/auto_retrain.py

Performans Kriterleri:
- Accuracy d√º≈ü√º≈ü√º: Son 7 g√ºn vs √∂nceki 30 g√ºn
- Trend analizi: Negatif trend tespiti
- Minimum sample size: 100 prediction
- Threshold: %5 d√º≈ü√º≈ü veya %85 altƒ± accuracy
"""

import os
import shutil
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import argparse
import warnings
warnings.filterwarnings('ignore')

import numpy as np
import pandas as pd
import joblib

from prediction_logger import PredictionLogger


class AutoRetrain:
    """Otomatik model re-training sistemi."""
    
    def __init__(
        self,
        db_path: str = "predictions.db",
        models_dir: str = "models",
        data_dir: str = "prepared_data",
        backup_dir: str = "model_backups"
    ):
        """
        Args:
            db_path: Predictions veritabanƒ±
            models_dir: Model dosyalarƒ± dizini
            data_dir: Training data dizini
            backup_dir: Backup dizini
        """
        self.db_path = db_path
        self.models_dir = Path(models_dir)
        self.data_dir = Path(data_dir)
        self.backup_dir = Path(backup_dir)
        
        self.backup_dir.mkdir(exist_ok=True)
        
        self.logger = PredictionLogger(db_path)
        
        # Thresholds
        self.min_samples = 100  # Minimum tahmin sayƒ±sƒ±
        self.accuracy_threshold = 0.85  # Minimum kabul edilebilir accuracy
        self.drop_threshold = 0.05  # Maksimum kabul edilebilir d√º≈ü√º≈ü (%5)
        self.lookback_recent = 7  # Son N g√ºn (recent performance)
        self.lookback_baseline = 30  # Kar≈üƒ±la≈ütƒ±rma i√ßin N g√ºn (baseline)
        
        self.retrain_needed = {}
        self.performance_data = {}
        
        print("ü§ñ AutoRetrain ba≈ülatƒ±ldƒ±")
    
    def check_performance(self, model_name: str) -> Dict:
        """
        Model performansƒ±nƒ± kontrol et.
        
        Args:
            model_name: Model adƒ±
        
        Returns:
            Performans raporu
        """
        print(f"\nüìä {model_name} performansƒ± kontrol ediliyor...")
        
        # Recent performance (son 7 g√ºn)
        recent_start = (datetime.now() - timedelta(days=self.lookback_recent)).strftime('%Y-%m-%d')
        recent_query = f'''
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN is_correct = 1 THEN 1 ELSE 0 END) as correct,
                AVG(confidence) as avg_confidence
            FROM predictions
            WHERE model_name = ?
                AND actual_result IS NOT NULL
                AND DATE(timestamp) >= ?
        '''
        
        self.logger.cursor.execute(recent_query, (model_name, recent_start))
        recent_total, recent_correct, recent_conf = self.logger.cursor.fetchone()
        
        # Baseline performance (30 g√ºn √∂nce - 7 g√ºn √∂nce arasƒ±)
        baseline_start = (datetime.now() - timedelta(days=self.lookback_baseline)).strftime('%Y-%m-%d')
        baseline_end = recent_start
        
        baseline_query = f'''
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN is_correct = 1 THEN 1 ELSE 0 END) as correct,
                AVG(confidence) as avg_confidence
            FROM predictions
            WHERE model_name = ?
                AND actual_result IS NOT NULL
                AND DATE(timestamp) >= ?
                AND DATE(timestamp) < ?
        '''
        
        self.logger.cursor.execute(baseline_query, (model_name, baseline_start, baseline_end))
        baseline_total, baseline_correct, baseline_conf = self.logger.cursor.fetchone()
        
        # Hesaplamalar
        recent_accuracy = recent_correct / recent_total if recent_total else 0.0
        baseline_accuracy = baseline_correct / baseline_total if baseline_total else 0.0
        
        accuracy_drop = baseline_accuracy - recent_accuracy
        drop_percentage = (accuracy_drop / baseline_accuracy * 100) if baseline_accuracy > 0 else 0
        
        # Karar
        needs_retrain = False
        reasons = []
        
        if recent_total < self.min_samples:
            print(f"   ‚ÑπÔ∏è Yetersiz veri: {recent_total} < {self.min_samples}")
        else:
            # Accuracy d√º≈ü√ºk m√º?
            if recent_accuracy < self.accuracy_threshold:
                needs_retrain = True
                reasons.append(f"D√º≈ü√ºk accuracy: {recent_accuracy:.2%} < {self.accuracy_threshold:.2%}")
            
            # Performans d√º≈ü√º≈ü√º var mƒ±?
            if accuracy_drop > self.drop_threshold:
                needs_retrain = True
                reasons.append(f"Performans d√º≈ü√º≈ü√º: {drop_percentage:.1f}% (>{self.drop_threshold*100:.0f}%)")
            
            # Sonu√ß
            if needs_retrain:
                print(f"   ‚ö†Ô∏è RE-TRAINING GEREKLƒ∞!")
                for reason in reasons:
                    print(f"      - {reason}")
            else:
                print(f"   ‚úÖ Performans normal")
                print(f"      Recent: {recent_accuracy:.2%}")
                print(f"      Baseline: {baseline_accuracy:.2%}")
        
        report = {
            'model_name': model_name,
            'recent': {
                'period': f'{self.lookback_recent} days',
                'total': int(recent_total) if recent_total else 0,
                'correct': int(recent_correct) if recent_correct else 0,
                'accuracy': float(recent_accuracy),
                'avg_confidence': float(recent_conf) if recent_conf else 0.0
            },
            'baseline': {
                'period': f'{self.lookback_baseline}-{self.lookback_recent} days ago',
                'total': int(baseline_total) if baseline_total else 0,
                'correct': int(baseline_correct) if baseline_correct else 0,
                'accuracy': float(baseline_accuracy),
                'avg_confidence': float(baseline_conf) if baseline_conf else 0.0
            },
            'analysis': {
                'accuracy_drop': float(accuracy_drop),
                'drop_percentage': float(drop_percentage),
                'needs_retrain': needs_retrain,
                'reasons': reasons
            },
            'timestamp': datetime.now().isoformat()
        }
        
        return report
    
    def check_all_models(self) -> Dict[str, Dict]:
        """T√ºm modelleri kontrol et."""
        print("\n" + "="*80)
        print("üîç T√úM MODELLER KONTROL EDƒ∞Lƒ∞YOR")
        print("="*80)
        
        # T√ºm model isimlerini al
        self.logger.cursor.execute('''
            SELECT DISTINCT model_name FROM predictions
        ''')
        
        models = [row[0] for row in self.logger.cursor.fetchall()]
        
        all_reports = {}
        
        for model in models:
            report = self.check_performance(model)
            all_reports[model] = report
            
            if report['analysis']['needs_retrain']:
                self.retrain_needed[model] = report
        
        return all_reports
    
    def backup_model(self, model_filename: str) -> str:
        """Model backup olu≈ütur."""
        source = self.models_dir / model_filename
        
        if not source.exists():
            print(f"   ‚ö†Ô∏è Model bulunamadƒ±: {source}")
            return None
        
        # Backup filename (timestamp ile)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"{source.stem}_backup_{timestamp}{source.suffix}"
        backup_path = self.backup_dir / backup_filename
        
        # Kopyala
        shutil.copy2(source, backup_path)
        print(f"   ‚úÖ Backup olu≈üturuldu: {backup_path}")
        
        return str(backup_path)
    
    def retrain_model(self, model_type: str, force: bool = False):
        """
        Modeli yeniden eƒüit.
        
        Args:
            model_type: 'xgboost' veya 'lightgbm'
            force: Zorla re-train
        """
        print(f"\n{'='*80}")
        print(f"üîß {model_type.upper()} RE-TRAINING")
        print(f"{'='*80}")
        
        # Model dosyasƒ±
        if model_type.lower() == 'xgboost':
            model_file = 'xgb_v2.pkl'
            tuning_script = 'tune_xgboost.py'
        elif model_type.lower() == 'lightgbm':
            model_file = 'lgb_v2.pkl'
            tuning_script = 'tune_lightgbm.py'
        else:
            print(f"   ‚ùå Bilinmeyen model tipi: {model_type}")
            return
        
        # Backup
        print("\n1Ô∏è‚É£ Model backup...")
        backup_path = self.backup_model(model_file)
        
        # Veri g√ºncelle
        print("\n2Ô∏è‚É£ Veri g√ºncelleme...")
        self._update_training_data()
        
        # Re-train
        print("\n3Ô∏è‚É£ Model eƒüitimi...")
        success = self._run_training_script(tuning_script)
        
        if success:
            print(f"\n   ‚úÖ {model_type.upper()} re-training ba≈üarƒ±lƒ±!")
            
            # Version bilgisi g√ºncelle
            self._update_model_version(model_file)
            
        else:
            print(f"\n   ‚ùå {model_type.upper()} re-training ba≈üarƒ±sƒ±z!")
            
            # Rollback
            if backup_path and Path(backup_path).exists():
                print(f"   üîÑ Rollback yapƒ±lƒ±yor...")
                shutil.copy2(backup_path, self.models_dir / model_file)
                print(f"   ‚úÖ Model geri y√ºklendi")
    
    def _update_training_data(self):
        """Training data'yƒ± g√ºncelle."""
        # Historical data collection
        print("   ‚Ä¢ Yeni veri toplama...")
        
        try:
            import subprocess
            result = subprocess.run(
                ['python', 'historical_data_collector.py'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                print("   ‚úÖ Veri toplama ba≈üarƒ±lƒ±")
            else:
                print(f"   ‚ö†Ô∏è Veri toplama hatasƒ±: {result.stderr}")
        
        except Exception as e:
            print(f"   ‚ö†Ô∏è Veri toplama hatasƒ±: {e}")
        
        # Calculate factors
        print("   ‚Ä¢ Fakt√∂r hesaplama...")
        
        try:
            result = subprocess.run(
                ['python', 'calculate_historical_factors.py'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                print("   ‚úÖ Fakt√∂r hesaplama ba≈üarƒ±lƒ±")
            else:
                print(f"   ‚ö†Ô∏è Fakt√∂r hesaplama hatasƒ±: {result.stderr}")
        
        except Exception as e:
            print(f"   ‚ö†Ô∏è Fakt√∂r hesaplama hatasƒ±: {e}")
        
        # Prepare training data
        print("   ‚Ä¢ Dataset hazƒ±rlama...")
        
        try:
            result = subprocess.run(
                ['python', 'prepare_training_data.py'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                print("   ‚úÖ Dataset hazƒ±rlama ba≈üarƒ±lƒ±")
            else:
                print(f"   ‚ö†Ô∏è Dataset hazƒ±rlama hatasƒ±: {result.stderr}")
        
        except Exception as e:
            print(f"   ‚ö†Ô∏è Dataset hazƒ±rlama hatasƒ±: {e}")
    
    def _run_training_script(self, script_name: str) -> bool:
        """Training script'ini √ßalƒ±≈ütƒ±r."""
        print(f"   ‚Ä¢ {script_name} √ßalƒ±≈ütƒ±rƒ±lƒ±yor...")
        
        try:
            import subprocess
            result = subprocess.run(
                ['python', script_name],
                capture_output=True,
                text=True,
                timeout=1800  # 30 dakika
            )
            
            if result.returncode == 0:
                print(f"   ‚úÖ {script_name} ba≈üarƒ±lƒ±")
                return True
            else:
                print(f"   ‚ùå {script_name} hatasƒ±: {result.stderr}")
                return False
        
        except Exception as e:
            print(f"   ‚ùå Script hatasƒ±: {e}")
            return False
    
    def _update_model_version(self, model_file: str):
        """Model version bilgisini g√ºncelle."""
        metadata_file = model_file.replace('.pkl', '_metadata.json')
        metadata_path = self.models_dir / metadata_file
        
        if metadata_path.exists():
            try:
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                
                # Version g√ºncelle
                old_version = metadata.get('version', 'v2.0')
                new_version = self._increment_version(old_version)
                
                metadata['version'] = new_version
                metadata['retrain_date'] = datetime.now().isoformat()
                metadata['previous_version'] = old_version
                
                with open(metadata_path, 'w') as f:
                    json.dump(metadata, f, indent=2)
                
                print(f"   ‚úÖ Version g√ºncellendi: {old_version} ‚Üí {new_version}")
            
            except Exception as e:
                print(f"   ‚ö†Ô∏è Metadata g√ºncelleme hatasƒ±: {e}")
    
    def _increment_version(self, version: str) -> str:
        """Version numarasƒ±nƒ± artƒ±r."""
        try:
            # v2.0 ‚Üí v2.1, v2.9 ‚Üí v3.0
            parts = version.replace('v', '').split('.')
            major, minor = int(parts[0]), int(parts[1])
            
            minor += 1
            if minor >= 10:
                major += 1
                minor = 0
            
            return f"v{major}.{minor}"
        
        except:
            return version + "_retrained"
    
    def generate_report(self, all_reports: Dict, output_path: str = "retrain_report.json"):
        """Re-train raporu olu≈ütur."""
        print(f"\nüìÑ Rapor olu≈üturuluyor: {output_path}")
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'thresholds': {
                'min_samples': self.min_samples,
                'accuracy_threshold': self.accuracy_threshold,
                'drop_threshold': self.drop_threshold,
                'lookback_recent': self.lookback_recent,
                'lookback_baseline': self.lookback_baseline
            },
            'models_checked': len(all_reports),
            'models_needing_retrain': len(self.retrain_needed),
            'performance_reports': all_reports,
            'retrain_needed': list(self.retrain_needed.keys())
        }
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"   ‚úÖ Rapor kaydedildi")


def main():
    """Ana fonksiyon."""
    parser = argparse.ArgumentParser(
        description='Otomatik model re-training sistemi'
    )
    parser.add_argument(
        '--check-only',
        action='store_true',
        help='Sadece performans kontrol√º yap, re-train yapma'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Zorla re-training yap'
    )
    parser.add_argument(
        '--model',
        type=str,
        choices=['xgboost', 'lightgbm', 'all'],
        default='all',
        help='Re-train yapƒ±lacak model'
    )
    parser.add_argument(
        '--db-path',
        type=str,
        default='predictions.db',
        help='Veritabanƒ± yolu'
    )
    
    args = parser.parse_args()
    
    # AutoRetrain
    auto_retrain = AutoRetrain(db_path=args.db_path)
    
    # Performans kontrol√º
    all_reports = auto_retrain.check_all_models()
    
    # Rapor olu≈ütur
    auto_retrain.generate_report(all_reports)
    
    # Re-training
    if not args.check_only:
        if args.force or auto_retrain.retrain_needed:
            print("\n" + "="*80)
            print("üîß RE-TRAINING BA≈ûLIYOR")
            print("="*80)
            
            if args.model == 'all' or args.model == 'xgboost':
                auto_retrain.retrain_model('xgboost', force=args.force)
            
            if args.model == 'all' or args.model == 'lightgbm':
                auto_retrain.retrain_model('lightgbm', force=args.force)
        else:
            print("\n‚úÖ T√ºm modeller iyi durumda, re-training gerekmedi")
    
    # Kapat
    auto_retrain.logger.close()
    
    print("\n" + "="*80)
    print("‚úÖ OTOMATIK RE-TRAINING TAMAMLANDI")
    print("="*80)


if __name__ == "__main__":
    main()
